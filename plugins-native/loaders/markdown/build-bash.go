package mainNative

import (
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/sirupsen/logrus"

	"gitlab.com/youtopia.earth/ops/snip/errors"
	"gitlab.com/youtopia.earth/ops/snip/plugin/loader"
)

type CodeBlockType int

const (
	CodeBlockBash CodeBlockType = iota
)

type CodeBlock struct {
	Type    CodeBlockType
	Content string
}

func BuildBash(cfg *loader.Config) error {
	mdpath := cfg.Command[0]

	codeBlocks, defaultsPlayProps := ParseMarkdownFile(cfg)
	cfg.DefaultsPlayProps = defaultsPlayProps

	now := time.Now()
	nowText := now.Format("2006-01-02 15:04:05")

	file := "build/snippets/" + mdpath + ".bash"
	dir := filepath.Dir(file)
	os.MkdirAll(dir, os.ModePerm)

	f, err := os.OpenFile(file, os.O_APPEND|os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	errors.Check(err)
	defer f.Close()
	outputAppend := func(str string) {
		_, err := f.WriteString(str)
		errors.Check(err)
	}

	outputAppend("#!/usr/bin/env bash\n\n")
	outputAppend("# play snippet: " + mdpath + "\n")
	outputAppend("# generated by snip on " + nowText + "\n\n")
	outputAppend("set -e\n\n")

	for _, codeBlock := range codeBlocks {
		content := codeBlock.Content
		content = strings.Trim(content, "\n")
		outputAppend(content + "\n")
	}

	outputAppend("\n\n# snip vars export \n")
	for _, vr := range cfg.RegisterVars {
		vr = strings.ToUpper(vr)
		outputAppend(`echo "${` + vr + `}">${SNIP_VARS_TREEPATH}/` + vr + "\n")
	}

	logrus.Debugf("writed bash from md to %v", file)

	// bin := filepath.Join("$SNIP_SNIPPETS_PATH", mdpath+".bash")
	// cfg.Command[0] = bin

	if err := BuildLauncher(cfg); err != nil {
		return err
	}

	cfg.RequiredFiles[file] = file

	return nil
}

func BuildLauncher(cfg *loader.Config) error {

	mdpath := cfg.Command[0]

	now := time.Now()
	nowText := now.Format("2006-01-02 15:04:05")

	file := "build/launchers/" + mdpath + ".bash"
	dir := filepath.Dir(file)
	os.MkdirAll(dir, os.ModePerm)

	f, err := os.OpenFile(file, os.O_APPEND|os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	errors.Check(err)
	defer f.Close()
	outputAppend := func(str string) {
		_, err := f.WriteString(str)
		errors.Check(err)
	}

	outputAppend("#!/bin/sh\n\n")
	outputAppend("# play launcher: " + mdpath + "\n")
	outputAppend("# generated by snip on " + nowText + "\n\n")
	outputAppend("set -e\n\n")

	outputAppend("\n\n# snip vars export \n")
	outputAppend("mkdir -p ${SNIP_VARS_TREEPATH}\n")
	binSnippet := filepath.Join("$SNIP_SNIPPETS_PATH", mdpath+".bash")
	if cfg.RegisterOutput != "" {
		vr := strings.ToUpper(cfg.RegisterOutput)
		outputAppend("exec " + binSnippet + `$@ | tee ${SNIP_VARS_TREEPATH}/` + vr + "\n")
	} else {
		outputAppend(binSnippet + "\n")
	}

	logrus.Debugf("writed launcher to %v", file)

	bin := filepath.Join("$SNIP_LAUNCHERS_PATH", mdpath+".bash")
	cfg.Command[0] = bin

	cfg.RequiredFiles[file] = file

	return nil
}
